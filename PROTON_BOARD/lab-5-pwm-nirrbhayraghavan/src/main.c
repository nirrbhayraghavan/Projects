#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/pwm.h"
#include "queue.h"
#include "support.h"

//////////////////////////////////////////////////////////////////////////////

const char* username = "raghav17";

//////////////////////////////////////////////////////////////////////////////

static int duty_cycle = 0;
static int dir = 0;
static int color = 0;

void display_init_pins();
void display_init_timer();
void display_char_print(const char message[]);
void keypad_init_pins();
void keypad_init_timer();
void init_wavetable(void);
void set_freq(int chan, float f);
extern KeyEvents kev;

//////////////////////////////////////////////////////////////////////////////

// When testing static duty-cycle PWM
//#define STEP2
// When testing variable duty-cycle PWM
//#define STEP3
// When testing 8-bit audio synthesis
#define STEP4

//////////////////////////////////////////////////////////////////////////////

void init_pwm_static(uint32_t period, uint32_t duty_cycle) {
    gpio_set_function(37, GPIO_FUNC_PWM);
    uint slice37 = pwm_gpio_to_slice_num(37);

    pwm_set_clkdiv(slice37, 150);
    pwm_set_wrap(slice37, period - 1);

    uint chan37  = pwm_gpio_to_channel(37);
    pwm_set_chan_level(slice37, chan37, duty_cycle);
    pwm_set_enabled(slice37, true);

    gpio_set_function(38, GPIO_FUNC_PWM);
    uint slice38 = pwm_gpio_to_slice_num(38);
    
    pwm_set_clkdiv(slice38, 150);
    pwm_set_wrap(slice38, period - 1);

    uint chan38  = pwm_gpio_to_channel(38);
    pwm_set_chan_level(slice38, chan38, duty_cycle);
    pwm_set_enabled(slice38, true);

    gpio_set_function(39, GPIO_FUNC_PWM);
    uint slice39 = pwm_gpio_to_slice_num(39);

    pwm_set_clkdiv(slice39, 150);
    pwm_set_wrap(slice39, period - 1);
    
    uint chan39  = pwm_gpio_to_channel(39);
    pwm_set_chan_level(slice39, chan39, duty_cycle);
    pwm_set_enabled(slice39, true);
}

void pwm_breathing() {
    uint slice37 = pwm_gpio_to_slice_num(37);
    pwm_clear_irq(slice37);

    if (dir == 0 && duty_cycle == 100)
        color = (color + 1) % 3;
    
    if (duty_cycle == 100 && dir == 0)
        dir = 1;
    else if (duty_cycle == 0 && dir == 1)
        dir = 0;

    if (dir == 0)
        duty_cycle = duty_cycle + 1;
    else
        duty_cycle = duty_cycle - 1;
    
    
    uint lvl = (duty_cycle * 10000) / 100;
    uint slice38 = pwm_gpio_to_slice_num(38);
    uint slice39 = pwm_gpio_to_slice_num(39);


    if (color == 0) 
        pwm_set_chan_level(slice37, PWM_CHAN_B, lvl);
    else if (color == 1)
        pwm_set_chan_level(slice38, PWM_CHAN_A, lvl); 
    else  
        pwm_set_chan_level(slice39, PWM_CHAN_B, lvl);

}

void init_pwm_irq() {
    uint slice37 = pwm_gpio_to_slice_num(37);
    uint slice38 = pwm_gpio_to_slice_num(38);
    uint slice39 = pwm_gpio_to_slice_num(39);
    uint chan37  = pwm_gpio_to_channel(37);
    uint chan38  = pwm_gpio_to_channel(38);
    uint chan39  = pwm_gpio_to_channel(39);

    pwm_set_irq0_enabled(slice37, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, pwm_breathing);
    irq_set_enabled(PWM_IRQ_WRAP, true);

    uint current_period = pwm_hw->slice[slice37].top + 1;

    duty_cycle = 100;   
    dir = 1;     

    pwm_set_chan_level(slice37, chan37, current_period);
    pwm_set_chan_level(slice38, chan38, current_period);
    pwm_set_chan_level(slice39, chan39, current_period);

}


void pwm_audio_handler() {
    uint slice36 = pwm_gpio_to_slice_num(36);
    pwm_clear_irq(slice36);
    offset0 = offset0 + step0;
    offset1 = offset1 + step1;

    if (offset0 >= (N << 16))
        offset0 = offset0 - (N << 16);
    if (offset1 >= (N << 16))
        offset1 = offset1 - (N << 16);
    
    int samp = wavetable[offset0 >> 16] + wavetable[offset1 >> 16];
    samp = samp / 2;

    uint current_period = pwm_hw->slice[slice36].top + 1;
    samp = (samp * current_period) >> 16;

    uint chan36 = pwm_gpio_to_channel(36);
    pwm_set_chan_level(slice36, chan36, samp);
}

void init_pwm_audio() {
    uint slice36 = pwm_gpio_to_slice_num(36);
    gpio_set_function(36, GPIO_FUNC_PWM);
    pwm_set_clkdiv(slice36, 150.0f);

    uint current_period = (1000000 / RATE) - 1;
    pwm_set_wrap(slice36, current_period);

    uint chan36 = pwm_gpio_to_channel(36);
    pwm_set_chan_level(slice36, chan36, 0);
    init_wavetable();
    pwm_clear_irq(slice36);

    pwm_set_irq0_enabled(slice36, true);
    irq_set_exclusive_handler(PWM_IRQ_WRAP, pwm_audio_handler);
    irq_set_enabled(PWM_IRQ_WRAP, true);
    pwm_set_enabled(slice36, true);
}

//////////////////////////////////////////////////////////////////////////////

int main()
{
    // Configures our microcontroller to 
    // communicate over UART through the TX/RX pins
    stdio_init_all();

    // Uncomment when you need to run autotest.
    // Keep this commented out until you need it
    // since it adds a lot of time to the upload process.
    autotest();

    /*
    ****************************************************
    * Make sure to go through the code in these steps.  
    * A lot of it can be very useful for your projects.
    ****************************************************
    */
   
   #ifdef STEP2
    // Make sure to copy in the latest display.c and keypad.c from your previous labs.
    keypad_init_pins();
    keypad_init_timer();
    display_init_pins();
    display_init_timer();

    init_pwm_static(100, 50); // Start out with 500/1000, 50%
    display_char_print("      50");
    uint16_t percent = 50; // Set initial percentage for duty cycle, displayed 
    uint16_t disp_buffer = 0;
    char buf[9];

    // Display initial duty cycle
    snprintf(buf, sizeof(buf), "      50");
    display_char_print(buf);

    bool new_entry = true;  // Flag to track if we're starting a new entry
    
    for (;;) {
        uint16_t keyevent = key_pop(); // Pop a key event from the queue
        if (keyevent & 0x100) {
            char key = keyevent & 0xFF;
            if (key >= '0' && key <= '9') {
                // If the key is a digit, check if we need to clear the buffer first
                if (new_entry) {
                    disp_buffer = 0;  // Clear the buffer for new entry
                    new_entry = false;  // No longer a new entry
                }
                // Shift into buffer
                disp_buffer = (disp_buffer * 10) + (key - '0');
                snprintf(buf, sizeof(buf), "%8d", disp_buffer);
                display_char_print(buf); // Display the new value
            } else if (key == '#') {
                // If the key is '#', set the duty cycle
                percent = disp_buffer;
                if (percent > 100) {
                    percent = 100; // Cap at 100%
                }
                init_pwm_static(100, percent); // Update PWM with new duty cycle
                snprintf(buf, sizeof(buf), "%8d", percent);
                display_char_print(buf); // Display the new duty cycle
                new_entry = true;  // Ready for new entry
            }
            else if (key == '*') {
                // If the key is '*', reset the buffer
                disp_buffer = 50;
                percent = 50;
                init_pwm_static(100, percent); // Reset PWM to 50% duty cycle
                snprintf(buf, sizeof(buf), "      50");
                display_char_print(buf); // Display reset
                new_entry = true;  // Ready for new entry
            }
            else {
                // Any other key also starts a new entry
                new_entry = true;
            }
        }
    }
    #endif

    #ifdef STEP3
    init_pwm_static(10000, 5000); // Start out with 500/1000, 50%
    init_pwm_irq(); // Initialize PWM IRQ for variable duty cycle

    for(;;) {
        // The handler manages everything from now on.
        // Use the CPU to do something else!
        tight_loop_contents();
    }
    #endif
    
    #ifdef STEP4
    

    char freq_buf[9] = {0};
    int pos = 0;
    bool decimal_entered = false;
    int decimal_pos = 0;
    int current_channel = 0;

    init_pwm_audio(); 
    keypad_init_pins();
    keypad_init_timer();
    display_init_pins();
    display_init_timer();
    set_freq(0, 440.0f); 
    display_char_print(" 440.000 ");

    for(;;) {
        uint16_t keyevent = key_pop();

        if (keyevent & 0x100) {
            char key = keyevent & 0xFF;
            if (key == 'A') {
                current_channel = 0;
                pos = 0;
                freq_buf[0] = '\0';
                decimal_entered = false;
                decimal_pos = 0;
                display_char_print("         ");
            } else if (key == 'B') {
                current_channel = 1;
                pos = 0;
                freq_buf[0] = '\0';
                decimal_entered = false;
                decimal_pos = 0;
                display_char_print("         ");
            } else if (key >= '0' && key <= '9') {
                if (pos == 0) {
                    snprintf(freq_buf, sizeof(freq_buf), "        "); // Clear buffer on first digit
                    display_char_print(freq_buf);
                }
                if (pos < 8) {
                    freq_buf[pos++] = key;
                    freq_buf[pos] = '\0';
                    display_char_print(freq_buf);
                    if (decimal_entered) decimal_pos++;
                }
                } else if (key == '*') {
                if (!decimal_entered && pos < 7) {
                    freq_buf[pos++] = '.';
                    freq_buf[pos] = '\0';
                    display_char_print(freq_buf);
                    decimal_entered = true;
                    decimal_pos = 0;
                }
                } else if (key == '#') {
                float freq = 0.0f;
                if (decimal_entered) {
                    freq = strtof(freq_buf, NULL);
                } else {
                    freq = (float)atoi(freq_buf);
                }
                set_freq(current_channel, freq);
                snprintf(freq_buf, sizeof(freq_buf), "%8.3f", freq);
                display_char_print(freq_buf);
                pos = 0;
                freq_buf[0] = '\0';
                decimal_entered = false;
                decimal_pos = 0;
            } else {
                // Reset on any other key
                pos = 0;
                freq_buf[0] = '\0';
                decimal_entered = false;
                decimal_pos = 0;
                display_char_print("        ");
            }
        }
    }
    #endif

    while (true) {
        printf("Hello, world!\n");
        sleep_ms(1000);
    }

    for(;;);
    return 0;
}
